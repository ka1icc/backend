# Описание задания (TASK)

---

## Суть задания

Нужно было сделать бэкенд (API), который отдаёт данные о погоде. В качестве источника данных — сервис AccuWeather: у них есть бесплатный доступ для разработчиков, нужно только зарегистрироваться и получить ключ API. Город в задании можно было зашить один раз в настройках; в этом проекте выбран город Казань (его ключ локации в AccuWeather — 295954).

 К  API авторизация не нужна — все эндпоинты открытые, любой может отправить запрос. Ожидаемая нагрузка небольшая: примерно 5 запросов в секунду на один эндпоинт (RPS — requests per second). То есть не нужна супер-оптимизация, но и дёргать внешний API при каждом запросе нежелательно, поэтому в проекте сделан кеш.

---

## Что именно нужно было реализовать

### 1. Текущая температура

- **Эндпоинт:** `GET /weather/current`
- **Суть:** При запросе отдаём текущую температуру по выбранному городу. Данные берём из AccuWeather (у них есть эндпоинт «текущие условия» по ключу локации). В ответе ожидается температура в градусах Цельсия и время наблюдения (например, в виде Unix timestamp), чтобы на фронте можно было показать и значение, и когда оно было зафиксировано.

### 2. Почасовая температура за последние 24 часа

- **Эндпоинт:** `GET /weather/historical`
- **Суть:** Нужно отдать список наблюдений по часам за последние сутки. В AccuWeather для этого есть отдельный API: historical/24 (в задании была ссылка: currentconditions/v1/{locationKey}/historical/24). Каждый элемент списка — температура и время (timestamp и/или строка с датой-временем), чтобы можно было вывести и «−12 °C в 14:00», и т.д.

### 3. Максимальная температура за 24 часа

- **Эндпоинт:** `GET /weather/historical/max`
- **Суть:** Одно число — самая высокая температура из почасовых данных за последние 24 часа. То есть мы берём тот же список, что и для `/weather/historical`, и возвращаем только максимум по полю «температура».

### 4. Минимальная температура за 24 часа

- **Эндпоинт:** `GET /weather/historical/min`
- **Суть:** Аналогично максу, но возвращаем минимальное значение температуры из того же списка за 24 часа.

### 5. Средняя температура за 24 часа

- **Эндпоинт:** `GET /weather/historical/avg`
- **Суть:** Среднее арифметическое по всем почасовым значениям за 24 часа: сумма температур делённая на количество наблюдений.

### 6. Поиск температуры по времени

- **Эндпоинт:** `GET /weather/by_time?timestamp=...`
- **Суть:** В параметре передаётся Unix timestamp (например, 1621823790 — это 2021-05-24 08:00). В ответ — температура, ближайшая к этому моменту по имеющимся данным (то есть ищем запись с минимальной разницей по времени). Если подходящих данных нет — ответ 404. Данные для поиска берутся из того, что мы уже сохранили в базу (при запросах к current и historical).

### 7. Проверка работы бэкенда

- **Эндпоинт:** `GET /health`
- **Суть:** Простая проверка, что сервер запущен и отвечает. Можно всегда отдавать OK (или короткий JSON вроде `{"status": "ok"}`). Нужно для мониторинга и для проверки, что приложение поднялось.

---

## Процесс разработки (подробно)


### Настройка проекта и конфиг

Сначала создала структуру проекта: папка `app`, в ней модули для роутов, моделей, схем, сервисов. Подключила FastAPI, прописала зависимость от базы (PostgreSQL через asyncpg). Все настройки вынесла в конфиг, который читается из переменных окружения и файла `.env`: ссылка на базу (`DATABASE_URL`), ключ AccuWeather (`ACCUWEATHER_API_KEY`), ключ города (`LOCATION_KEY`). Так ничего не захардкожено в коде, и при запуске локально или в Docker можно подставить свои значения.

### Клиент к AccuWeather

Сделала отдельный моодуль (в проекте это `app/services/accuweather.py`) — класс, который умеет вызывать только нужные нам эндпоинты AccuWeather:

1. Текущие условия — один запрос по адресу вида `currentconditions/v1/{locationKey}`. Ответ приходит массивом, беру первый элемент.
2. Почасовая история за 24 часа — запрос к `currentconditions/v1/{locationKey}/historical/24`. Ответ — массив объектов, в каждом есть время (EpochTime) и температура (внутри объекта Temperature → Metric → Value).

В этом же модуле написала маленькие функции, которые из сырого JSON достают температуру в градусах и время в виде числа (timestamp). Так весь парсинг AccuWeather сосредоточен в одном месте, и если у них поменяется формат, править нужно только здесь.

### Сервис с кешем

Чтобы не обращаться к AccuWeather при каждом запросе пользователя, добавила слой «кеш» (файл `app/services/weather_cache.py`). Логика такая:

- Для текущей погоды и для истории за 24 ч завёла отдельные кеши в памяти (`cachetools.TTLCache`): данные хранятся несколько минут (в настройках можно задать TTL в секундах). При запросе сначала проверяем: есть ли уже данные в кеше для нашего города. Если есть — возвращаем их, к AccuWeather не ходим. Если нет — вызываем клиент AccuWeather, получаем ответ, парсим, складываем в кеш и отдаём вызывающему коду. Так при нескольких запросах подряд или при открытии главной страницы мы не бьём лишний раз по внешнему API и укладываемся в разумную нагрузку.

- Для текущей температуры сделала запасной вариант: если эндпоинт «текущие условия» у AccuWeather не ответил или вернул пусто (например, по тарифу ключа бывает ограничение), то текущей температурой считаем последнее по времени наблюдение из почасовой истории за 24 ч. То есть один раз запрашиваем historical/24, находим запись с максимальным временем — её температуру и время отдаём как «текущую». Так на главной странице что-то всё равно отображается.

- Для макс/мин/среднего за 24 ч отдельно в AccuWeather не ходим: один раз получаем список почасовых данных (через тот же метод, что отдаёт `/weather/historical`), и из этого списка в коде считаем максимум, минимум и среднее арифметическое. То есть один источник данных, все агрегаты считаются из него.

### Роуты (эндпоинты)

Каждый пункт из задания оформила как отдельный маршрут в FastAPI (файл `app/routers/weather.py`):

- `/weather/current` — вызывает сервис «получить текущую» (с кешем и fallback из истории), проверяет, что температура и время есть, и отдаёт их в виде JSON по схеме (temperature_c, observed_at_epoch).
- `/weather/historical` — вызывает сервис «получить почасовую историю за 24 ч», возвращает список с полями epoch_time, temperature_c, observed_at_iso.
- `/weather/historical/max`, `/historical/min`, `/historical/avg` — вызывают сервис за тем же списком истории, потом в роуте берётся уже посчитанное значение (max, min или avg) и отдаётся в формате типа `{"value_c": число, "kind": "max"}` (или min/avg). Важно: в FastAPI порядок объявления роутов имеет значение. Чтобы запрос к `/weather/historical/max` не обрабатывался как что-то другое, эти три маршрута (max, min, avg) объявлены в коде раньше, чем общий `/weather/historical`.
- `/weather/by_time?timestamp=...` — в сервисе ищем в базе запись с ближайшим к переданному timestamp, отдаём её температуру и время; если в базе ничего нет — 404.
- Отдельно роут `/health` (в своём маленьком роутере) — всегда отдаёт успешный ответ, чтобы было видно, что бэкенд живой.

Схемы ответов (что за поля в JSON) описаны в Pydantic-моделях в `app/schemas/weather.py`, чтобы и документация в Swagger была аккуратная, и типы предсказуемые.

### База данных

Подключение к PostgreSQL и создание таблиц делаются при старте приложения (через lifespan в `app/main.py` и код в `app/database.py`). Модель одна: таблица с наблюдениями — ключ локации, время (epoch и дата), температура, при желании текст погоды, время создания записи. Когда из AccuWeather приходят данные (текущие или почасовая история), мы пробуем сохранить их в эту таблицу (добавляем запись и делаем flush). Если база недоступна или ошибка — ловим исключение и просто продолжаем работать без записи; отдаём данные из кеша. То есть приложение может работать и без базы, но тогда эндпоинт «по времени» не сможет ничего найти (будет 404), пока в базе не появятся данные.

Поиск по времени реализован так: в базе выбираем запись с заданным location_key, сортируем по минимальной разнице между полем времени и переданным timestamp, берём одну запись. Если есть — отдаём её температуру и время, если нет — 404.

### Веб-страница (главная)

Сделала простую HTML-страницу (в `app/static/index.html`), которая при открытии главной страницы сайта запрашивает наш API и выводит блоки: текущая температура, макс за 24 ч, мин за 24 ч, среднее за 24 ч, и список почасовых значений. Изначально делал так, что для каждого блока был отдельный запрос: `/weather/current`, `/weather/historical/max`, `/weather/historical/min`, `/weather/historical/avg`, `/weather/historical`. На практике оказалось, что иногда текущая температура или макс не отображались (то ли эндпоинт AccuWeather не отдавал текущие условия, то ли с маршрутами была путаница). Поэтому логику главной страницы поменяла: теперь она один раз запрашивает только `/weather/historical`, получает полный список почасовых данных, и сама в JavaScript считает: текущая — это запись с самым поздним временем в списке; макс — максимум по температурам; мин — минимум; среднее — сумма температур делённая на количество. Список по часам рисуется из того же массива. Так все цифры на странице всегда из одного ответа, ничего не «пропадает», и не важно, как в данный момент работают отдельные эндпоинты current или historical/max.


## Как всё работает

### Пользователь открывает главную страницу

1. Браузер запрашивает у нашего сервера страницу (GET `/`). Сервер отдаёт HTML из `app/static/index.html`.
2. В этой странице написан скрипт, который при загрузке один раз вызывает наш API: GET `/weather/historical`.
3. Запрос приходит в FastAPI. Обрабатывается роут `/weather/historical`. Он вызывает сервис «получить почасовую историю за 24 ч».
4. В сервисе сначала проверяется кеш: есть ли уже список за последние N минут. Если есть — он возвращается сразу. Если нет — сервис дергает клиент AccuWeather (запрос к их historical/24), получает JSON, парсит температуру и время по каждому элементу, при возможности пишет наблюдения в PostgreSQL и кладёт список в кеш. Список возвращается в роут.
5. Роут оформляет ответ по схеме (hourly: массив с epoch_time, temperature_c, observed_at_iso) и отдаёт JSON клиенту.
6. В браузере JavaScript получает этот JSON. Из массива hourly берётся запись с максимальным epoch_time — её температура и время показываются как «текущая температура». По всем элементам считаются максимум, минимум и среднее по полю temperature_c — эти значения выводятся в блоках «Макс за 24 ч», «Мин за 24 ч», «Средн. за 24 ч». Тот же массив выводится построчно в блоке «Почасовая температура».

